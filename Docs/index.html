<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-12-24 Wed 21:58 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="author" content="Akilan" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/code-copy.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/search.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/search.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/code-copy.js"></script>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/search.css"/>
<link rel="stylesheet" type="text/css" href="style.css"/>
</head>
<body>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9f42d24">1. Guide through video</a>
<ul>
<li>
<ul>
<li><a href="#orgb9c539a">1.0.1. The video below shows the setup and usage of P2PRC.</a></li>
<li><a href="#org967c445">1.0.2. Source code: https://github.com/Akilan1999/p2p-rendering-computation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter1-introduction">2. Introduction</a>
<ul>
<li><a href="#motivation">2.1. Motivation</a></li>
</ul>
</li>
<li><a href="#installation">3. Installation</a>
<ul>
<li><a href="#latest-release-install">3.1. Latest release install</a></li>
<li><a href="#install-from-github-master-branch">3.2. Install from Github master branch</a>
<ul>
<li><a href="#install-go-lang">3.2.1. Install Go lang</a></li>
<li><a href="#install-docker">3.2.2. Install Docker</a></li>
<li><a href="#build-project-and-install-project">3.2.3. Build Project and install project</a></li>
<li><a href="#add-appropriate-paths-to-.bashrc">3.2.4. Add appropriate paths to <code>.bashrc</code></a></li>
<li><a href="#test-if-binary-works">3.2.5. Test if binary works</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgadbccde">4. Nix Flake</a>
<ul>
<li><a href="#org92f9e41">4.1. P2PRC core Go language repo</a></li>
<li><a href="#org3b69d7c">4.2. P2PRC Haskell library</a>
<ul>
<li><a href="#orgd82fbf3">4.2.1. Nix:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#using-basic-commands">5. Using basic commands</a>
<ul>
<li>
<ul>
<li><a href="#start-as-a-server">5.0.1. Start as a server</a></li>
<li><a href="#view-server-specification">5.0.2. View server Specification</a></li>
<li><a href="#run-container">5.0.3. Run container</a></li>
<li><a href="#remove-container">5.0.4. Remove container</a></li>
<li><a href="#adding-servers-to-ip-table">5.0.5. Adding servers to ip table</a></li>
<li><a href="#update-ip-table">5.0.6. Update ip table</a></li>
<li><a href="#list-servers">5.0.7. List Servers</a></li>
<li><a href="#view-network-interfaces">5.0.8. View Network interfaces</a></li>
<li><a href="#viewing-containers-created-client-side">5.0.9. Viewing Containers created Client side</a></li>
<li><a href="#running-plugin">5.0.10. Running plugin</a></li>
<li><a href="#create-group">5.0.11. Create group</a></li>
<li><a href="#add-container-to-group">5.0.12. Add container to group</a></li>
<li><a href="#view-groups">5.0.13. View groups</a></li>
<li><a href="#view-specific-group">5.0.14. View specific group</a></li>
<li><a href="#delete-container-from-group">5.0.15. Delete container from group</a></li>
<li><a href="#delete-entire-group">5.0.16. Delete entire group</a></li>
<li><a href="#pulling-plugin-from-a-remote-repo">5.0.17. Pulling plugin from a remote repo</a></li>
<li><a href="#deleting-plugin-from-the-plugin-directory">5.0.18. Deleting plugin from the plugin directory</a></li>
<li><a href="#added-custom-metadata-about-the-current-node">5.0.19. Added custom metadata about the current node</a></li>
<li><a href="#orgad06634">5.0.20. MapPort and link to domain name</a></li>
<li><a href="#orgfe7c95c">5.0.21. Add root node</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#p2p-module-implementation">6. P2P Module Implementation</a>
<ul>
<li><a href="#ip-table">6.1. IP Table</a>
<ul>
<li><a href="#latency">6.1.1. Latency</a></li>
</ul>
</li>
<li><a href="#nat-traversal">6.2. NAT Traversal</a></li>
<li><a href="#turn">6.3. TURN</a>
<ul>
<li><a href="#client-mode">6.3.1. Client mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#language-bindings">7. Language Bindings</a>
<ul>
<li><a href="#how-to-build-shared-object-files">7.1. How to build shared object files</a></li>
<li><a href="#workings-under-the-hood">7.2. Workings under the hood</a>
<ul>
<li><a href="#in-client-go">7.2.1. In Client go</a></li>
</ul>
</li>
<li><a href="#current-languages-supported">7.3. Current languages supported</a>
<ul>
<li><a href="#org2c0e1e0">7.3.1. Python</a></li>
<li><a href="#org6e90444">7.3.2. Haskell</a></li>
</ul>
</li>
<li><a href="#org833da84">7.4. Building P2PRC modules in Rust</a>
<ul>
<li><a href="#orga14ed63">7.4.1. A simple Hello Rust module</a></li>
<li><a href="#org6a54c3a">7.4.2. Important notes for creates future Rust modules</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#config-implementation">8. Config Implementation</a></li>
<li><a href="#abstractions">9. Abstractions</a>
<ul>
<li><a href="#functions">9.1. Functions</a></li>
</ul>
</li>
<li><a href="#nat-traversal">10. NAT Traversal</a>
<ul>
<li><a href="#turn">10.1. TURN</a></li>
</ul>
</li>
<li><a href="#client-mode">11. Client mode</a></li>
<li><a href="#org5f3cbd3">12. Simulation</a>
<ul>
<li><a href="#orgfd89349">12.1. Command</a></li>
<li><a href="#orgfa04801">12.2. Sample bash instructions</a></li>
</ul>
</li>
<li><a href="#orge4d9db0">13. Blog posts</a>
<ul>
<li><a href="#orgfca689c">13.1. Self host within 5 minutes any program</a>
<ul>
<li><a href="#org913042c">13.1.1. 1. Find a program you want to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org57efbd3">14. Ideas for future potencial features</a>
<ul>
<li><a href="#org49c2bde">14.1. To support hetrogenous set of Nodes that cannot run P2PRC</a>
<ul>
<li><a href="#org3252eff">14.1.1. Assumptions:</a></li>
<li><a href="#orgdfb7f68">14.1.2. Set of interesting possible:</a></li>
<li><a href="#org4bd7b29">14.1.3. Implementation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="org0aedfc8" class="figure">
<p><img src="./Colored-On-Light-Image.png" alt="Colored-On-Light-Image.png" width="300px" />
</p>
</div>
<div id="outline-container-org9f42d24" class="outline-2">
<h2 id="org9f42d24"><span class="section-number-2">1.</span> Guide through video</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgb9c539a" class="outline-4">
<h4 id="orgb9c539a"><span class="section-number-4">1.0.1.</span> The video below shows the setup and usage of P2PRC.</h4>
<div class="outline-text-4" id="text-1-0-1">

<div id="org6ca72a4" class="figure">
<p><a href="https://www.youtube.com/watch?v=OMwCpedu5cs" class="video"><img src="https://i3.ytimg.com/vi/OMwCpedu5cs/maxresdefault.jpg" alt="maxresdefault.jpg" class="video" /></a>
</p>
</div>
</div>
</div>
<div id="outline-container-org967c445" class="outline-4">
<h4 id="org967c445"><span class="section-number-4">1.0.2.</span> Source code: <a href="https://github.com/Akilan1999/p2p-rendering-computation">https://github.com/Akilan1999/p2p-rendering-computation</a></h4>
</div>
</div>
<div id="outline-container-chapter1-introduction" class="outline-2">
<h2 id="chapter1-introduction"><span class="section-number-2">2.</span> Introduction</h2>
<div class="outline-text-2" id="text-chapter1-introduction">
<p>
This project focuses on creating a framework for running heavy computational tasks that a regular
computer cannot handle easily. These tasks may include graphically demanding video games, rendering
3D animations, and performing complex protein folding simulations. The major focus of this project
is not on financial incentives but rather on building a robust and efficient peer-to-peer (P2P)
network to decentralise task execution and increase the computational bandwidth available for
such tasks.
</p>

<p>
The P2PRC framework serves as a foundation for decentralised rendering and computation,
providing insights into how tasks can be distributed efficiently across a network of peers.
Leveraging the P2PRC approach, this project extends its capabilities to handle a
wider range of computationally intensive tasks.
</p>
</div>
<div id="outline-container-motivation" class="outline-3">
<h3 id="motivation"><span class="section-number-3">2.1.</span> Motivation</h3>
<div class="outline-text-3" id="text-motivation">
<p>
Many of the users rely on our PC / Laptop or servers that belong to a
server farm to run heavy tasks and with the demand of high creativity
requires higher computing power. Buying a powerful computer every few
years to run a bunch of heavy tasks which are not executed as frequently
to reap the benefits can be inefficient utilization of hardware. On the
other end, renting servers to run these heavy tasks can be really
useful. Ethically speaking this is leading to monopolisation of
computing power similar to what is happening in the web server area. By
using peer to peer principles it is possible to remove the
monopolisation factor and increase the bandwidth between the client and
server.
</p>
</div>
</div>
</div>
<div id="outline-container-installation" class="outline-2">
<h2 id="installation"><span class="section-number-2">3.</span> Installation</h2>
<div class="outline-text-2" id="text-installation">
<p>
Over here we will cover the basic steps to get the server and client
side running.
</p>
</div>
<div id="outline-container-latest-release-install" class="outline-3">
<h3 id="latest-release-install"><span class="section-number-3">3.1.</span> Latest release install</h3>
<div class="outline-text-3" id="text-latest-release-install">
<p>
<a href="https://github.com/Akilan1999/p2p-rendering-computation/releases">https://github.com/Akilan1999/p2p-rendering-computation/releases</a>
</p>
</div>
</div>
<div id="outline-container-install-from-github-master-branch" class="outline-3">
<h3 id="install-from-github-master-branch"><span class="section-number-3">3.2.</span> Install from Github master branch</h3>
<div class="outline-text-3" id="text-install-from-github-master-branch">
</div>
<div id="outline-container-install-go-lang" class="outline-4">
<h4 id="install-go-lang"><span class="section-number-4">3.2.1.</span> Install Go lang</h4>
<div class="outline-text-4" id="text-install-go-lang">
<p>
The entire the implementation of this project is done using Go lang.
Thus, we need go lang to compile to code to a binary file.
<a href="https://golang.org/doc/install">Instructions to install Go lang</a>
</p>
</div>
</div>
<div id="outline-container-install-docker" class="outline-4">
<h4 id="install-docker"><span class="section-number-4">3.2.2.</span> Install Docker</h4>
<div class="outline-text-4" id="text-install-docker">
<p>
In this project the choice of virtualization is Docker due to it's wide
usage in the developer community. In the server module we use the Docker
Go API to create and interact with the containers.
</p>

<p>
<a href="https://docs.docker.com/get-docker/">Instructions to install docker</a>
</p>

<p>
<a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker">Instructions
to install docker GPU</a>
</p>

<pre class="example" id="org109a81f">
// Do ensure that the docker command does not need sudo to run
sudo chmod 666 /var/run/docker.sock
</pre>
</div>
</div>
<div id="outline-container-build-project-and-install-project" class="outline-4">
<h4 id="build-project-and-install-project"><span class="section-number-4">3.2.3.</span> Build Project and install project</h4>
<div class="outline-text-4" id="text-build-project-and-install-project">
<p>
To set up the internal dependencies and build the entire go code into a
single binary
</p>

<pre class="example" id="org6f8836d">
make
</pre>
</div>
<ol class="org-ol">
<li><a id="for-windows"></a>For Windows<br />
<div class="outline-text-5" id="text-for-windows">
<p>
To set up P2PRC on Windows, simply run this batch file. <b>Make sure you
are not in admin mode when running this.</b>
</p>

<pre class="example" id="org6826d38">
.\install.bat
</pre>
</div>
</li>
</ol>
</div>
<div id="outline-container-add-appropriate-paths-to-.bashrc" class="outline-4">
<h4 id="add-appropriate-paths-to-.bashrc"><span class="section-number-4">3.2.4.</span> Add appropriate paths to <code>.bashrc</code></h4>
<div class="outline-text-4" id="text-add-appropriate-paths-to-.bashrc">
<pre class="example" id="org5cbdae7">
export P2PRC=/&lt;PATH&gt;/p2p-rendering-computation
export PATH=/&lt;PATH&gt;/p2p-rendering-computation:${PATH}
</pre>
</div>
</div>
<div id="outline-container-test-if-binary-works" class="outline-4">
<h4 id="test-if-binary-works"><span class="section-number-4">3.2.5.</span> Test if binary works</h4>
<div class="outline-text-4" id="text-test-if-binary-works">
<pre class="example" id="orgba969e4">
p2prc --help
</pre>
</div>
<ol class="org-ol">
<li><a id="output"></a>Output:<br />
<div class="outline-text-5" id="text-output">
<pre class="example" id="orgec86da3">
NAME:
   p2p-rendering-computation - p2p cli application to create and access VMs in other servers

USAGE:
   p2prc [global options] command [command options] [arguments...]

VERSION:
   2.0.0

COMMANDS:
   help, h  Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --Server, -s                           Starts server (default: false) [$SERVER]
   --UpdateServerList, --us               Update List of Server available based on servers iptables (default: false) [$UPDATE_SERVER_LIST]
   --ListServers, --ls                    List servers which can render tasks (default: false) [$LIST_SERVERS]
   --AddServer value, --as value          Adds server IP address to iptables [$ADD_SERVER]
   --ViewImages value, --vi value         View images available on the server IP address [$VIEW_IMAGES]
   --CreateVM value, --touch value        Creates Docker container on the selected server [$CREATE_VM]
   --ContainerName value, --cn value      Specifying the container run on the server side [$CONTAINER_NAME]
   --BaseImage value, --bi value          Specifying the docker base image to template the dockerfile [$CONTAINER_NAME]
   --RemoveVM value, --rm value           Stop and Remove Docker container (IP:port) accompanied by container ID via --ID or --id [$REMOVE_VM]
   --ID value, --id value                 Docker Container ID [$ID]
   --Ports value, -p value                Number of ports to open for the Docker Container [$NUM_PORTS]
   --GPU, --gpu                           Create Docker Containers to access GPU (default: false) [$USE_GPU]
   --Specification value, --specs value   Specs of the server node [$SPECS]
   --SetDefaultConfig, --dc               Sets a default configuration file (default: false) [$SET_DEFAULT_CONFIG]
   --NetworkInterfaces, --ni              Shows the network interface in your computer (default: false) [$NETWORK_INTERFACE]
   --ViewPlugins, --vp                    Shows plugins available to be executed (default: false) [$VIEW_PLUGIN]
   --TrackedContainers, --tc              View (currently running) containers which have been created from the client side  (default: false) [$TRACKED_CONTAINERS]
   --ExecutePlugin value, --plugin value  Plugin which needs to be executed [$EXECUTE_PLUGIN]
   --CreateGroup, --cgroup                Creates a new group (default: false) [$CREATE_GROUP]
   --Group value, --group value           group flag with argument group ID [$GROUP]
   --Groups, --groups                     View all groups (default: false) [$GROUPS]
   --RemoveContainerGroup, --rmcgroup     Remove specific container in the group (default: false) [$REMOVE_CONTAINER_GROUP]
   --RemoveGroup value, --rmgroup value   Removes the entire group [$REMOVE_GROUP]
   --MAPPort value, --mp value            Maps port for a specific port provided as the parameter [$MAPPORT]
   --DomainName value, --dn value         While mapping ports allows to set a domain name to create a mapping in the proxy server [$DOMAINNAME]
   --Generate value, --gen value          Generates a new copy of P2PRC which can be modified based on your needs [$GENERATE]
   --ModuleName value, --mod value        New go project module name [$MODULENAME]
   --PullPlugin value, --pp value         Pulls plugin from git repos [$PULLPLUGIN]
   --RemovePlugin value, --rp value       Removes plugin [$REMOVEPLUGIN]
   --AddMetaData value, --amd value       Adds metadata about the current node in the p2p network which is then propagated through the network [$ADDMETADATA]
   --help, -h                             show help (default: false)
   --version, -v                          print the version (default: false)
</pre>

<hr />
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgadbccde" class="outline-2">
<h2 id="orgadbccde"><span class="section-number-2">4.</span> Nix Flake</h2>
<div class="outline-text-2" id="text-4">
<p>
Nix is a growing ecosystem that allows flexibility on how you develop, build and package software and configurations. It brings all programming languages (and all other tooling) to an equal footing, despite deep design differences. More importantly, integrates all the "packaging" into the context of a "pure" function.
</p>


<p>
P2PRC aims to become a utility that can be used in various flexible manners and having Nix support is a good alternative to accomplish this goal.
</p>


<p>
Nix Flake is a format, within the Nix ecosystem, intentionally designed to encourage a standard in packaging distribution. The current packaging assumes that you have "nix flake" installed because it is currently an experimental feature of Nix.
</p>
</div>
<div id="outline-container-org92f9e41" class="outline-3">
<h3 id="org92f9e41"><span class="section-number-3">4.1.</span> P2PRC core Go language repo</h3>
<div class="outline-text-3" id="text-4-1">
<p>
In case you want to develop, build or integrate using nix, you just need to run either "nix develop" or "nix run" from the command line locally in a cloned git repository or by running "nix run github:akilan1999/p2p-rendering-computation &#x2013; &#x2013;help"
</p>


<p>
P2PRC library also is ready to be imported into other nix flakes. To accomplish that please make sure to override the target nixpkgs environment in the following manner;
</p>

<pre class="example" id="orgd58f070">
pkgs = import nixpkgs {
  inherit system;
  overlays = [
    p2prc-flake.overlays.default
  ];
};
</pre>


<p>
This will make the p2prc executable available in the environment of any application you use.
</p>
</div>
</div>
<div id="outline-container-org3b69d7c" class="outline-3">
<h3 id="org3b69d7c"><span class="section-number-3">4.2.</span> P2PRC Haskell library</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-orgd82fbf3" class="outline-4">
<h4 id="orgd82fbf3"><span class="section-number-4">4.2.1.</span> Nix:</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
The project is structured to provide language bindings to any programming language. The first one being supported in this manner is the Haskell programming language. It provides a bootstrapping script for a new Cabal project with p2prc binary available in the environment and, more relevantly, the Haskell library bindings available in the virtual environment cabal environment.
</p>

<pre class="example" id="org2a2bdbe">
nix run git+https://github.com/akilan1999/p2p-rendering-computation#initHaskellProject -- &lt;PROJECT_NAME&gt;
</pre>


<p>
This will generate a new haskell project setup to automatically work with the p2prc development and running environment.
</p>


<p>
Once completed, you should go into the project directory and copy the nix flake template, necessary to define the project's environment.
</p>

<pre class="example" id="org2f2dfec">
nix flake init -t github:akilan1999/p2p-rendering-computation#haskell
</pre>

<p>
The previous command sets up the flake environment and its dependencies. It will look like the following
</p>

<pre class="example" id="org3403e8e">
{
  description = "Start of Haskell P2PRC flake";

  inputs =
    {
      nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";

      flake-util.url = "github:numtide/flake-utils";

      p2prc-flake.url = "github:akilan1999/p2p-rendering-computation";
    };

  outputs = { nixpkgs, p2prc-flake, flake-utils, ... }:
    (flake-utils.lib.eachDefaultSystem (system:
      let

        pkgs = import nixpkgs {
          inherit system;
          overlays = [
            p2prc-flake.overlays.default
            p2prc-flake.overlays.bindings
          ];
        };

      in {

        packages.default = pkgs.haskellPackages.callPackage ./cabal.nix { };

        devShells.default = pkgs.haskellPackages.shellFor {

          packages = p: [
            (p.callPackage ./cabal.nix { })
          ];

          buildInputs = with pkgs; [
            p2prc-flake.packages.${system}.default
            ghc
            cabal2nix
            cabal-install
          ];

          shellHook = ''
            cabal2nix . &gt; ./cabal.nix
          '';
        };
      }
    ));
}
</pre>

<p>
The template uses Cabal2Nix which manages the Haskell virtual environment automatically. It applies the system overlays, sets up the shell environment for the project (updating the Cabal2Nix configuration) and packages the main executable.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-using-basic-commands" class="outline-2">
<h2 id="using-basic-commands"><span class="section-number-2">5.</span> Using basic commands</h2>
<div class="outline-text-2" id="text-using-basic-commands">
</div>
<div id="outline-container-start-as-a-server" class="outline-4">
<h4 id="start-as-a-server"><span class="section-number-4">5.0.1.</span> Start as a server</h4>
<div class="outline-text-4" id="text-start-as-a-server">
<pre class="example" id="orgadb54c3">
p2prc -s
</pre>
</div>
</div>
<div id="outline-container-view-server-specification" class="outline-4">
<h4 id="view-server-specification"><span class="section-number-4">5.0.2.</span> View server Specification</h4>
<div class="outline-text-4" id="text-view-server-specification">
<pre class="example" id="orgac7312c">
p2prc --specs=&lt;ip address&gt;
</pre>
</div>
</div>
<div id="outline-container-run-container" class="outline-4">
<h4 id="run-container"><span class="section-number-4">5.0.3.</span> Run container</h4>
<div class="outline-text-4" id="text-run-container">
<p>
use the <code>--gpu</code> if you know the other machine has a gpu.
</p>

<pre class="example" id="orga242d25">
p2prc --touch=&lt;server ip address&gt; -p &lt;number of ports&gt; --gpu
</pre>
</div>
</div>
<div id="outline-container-remove-container" class="outline-4">
<h4 id="remove-container"><span class="section-number-4">5.0.4.</span> Remove container</h4>
<div class="outline-text-4" id="text-remove-container">
<p>
The docker id is present in the output where you create a container
</p>

<pre class="example" id="org38d9e10">
p2prc --rm=&lt;server ip address&gt; --id=&lt;docker container id&gt;
</pre>
</div>
</div>
<div id="outline-container-adding-servers-to-ip-table" class="outline-4">
<h4 id="adding-servers-to-ip-table"><span class="section-number-4">5.0.5.</span> Adding servers to ip table</h4>
<div class="outline-text-4" id="text-adding-servers-to-ip-table">
<pre class="example" id="orgaa6ab83">
p2prc --as=&lt;server ip address you want to add&gt;
</pre>
</div>
</div>
<div id="outline-container-update-ip-table" class="outline-4">
<h4 id="update-ip-table"><span class="section-number-4">5.0.6.</span> Update ip table</h4>
<div class="outline-text-4" id="text-update-ip-table">
<pre class="example" id="orgeff880a">
p2prc --us
</pre>
</div>
</div>
<div id="outline-container-list-servers" class="outline-4">
<h4 id="list-servers"><span class="section-number-4">5.0.7.</span> List Servers</h4>
<div class="outline-text-4" id="text-list-servers">
<pre class="example" id="org4562295">
p2prc --ls
</pre>
</div>
</div>
<div id="outline-container-view-network-interfaces" class="outline-4">
<h4 id="view-network-interfaces"><span class="section-number-4">5.0.8.</span> View Network interfaces</h4>
<div class="outline-text-4" id="text-view-network-interfaces">
<pre class="example" id="orgaf597e8">
p2prc --ni
</pre>
</div>
</div>
<div id="outline-container-viewing-containers-created-client-side" class="outline-4">
<h4 id="viewing-containers-created-client-side"><span class="section-number-4">5.0.9.</span> Viewing Containers created Client side</h4>
<div class="outline-text-4" id="text-viewing-containers-created-client-side">
<pre class="example" id="org4642aaf">
p2prc --tc
</pre>
</div>
</div>
<div id="outline-container-running-plugin" class="outline-4">
<h4 id="running-plugin"><span class="section-number-4">5.0.10.</span> Running plugin</h4>
<div class="outline-text-4" id="text-running-plugin">
<pre class="example" id="org18145d5">
p2prc --plugin &lt;plugin name&gt; --id &lt;container id or group id&gt;
</pre>
</div>
</div>
<div id="outline-container-create-group" class="outline-4">
<h4 id="create-group"><span class="section-number-4">5.0.11.</span> Create group</h4>
<div class="outline-text-4" id="text-create-group">
<pre class="example" id="org9192f75">
p2prc --cgroup
</pre>
</div>
</div>
<div id="outline-container-add-container-to-group" class="outline-4">
<h4 id="add-container-to-group"><span class="section-number-4">5.0.12.</span> Add container to group</h4>
<div class="outline-text-4" id="text-add-container-to-group">
<pre class="example" id="org7def7a3">
p2prc --group &lt;group id&gt; --id &lt;container id&gt;
</pre>
</div>
</div>
<div id="outline-container-view-groups" class="outline-4">
<h4 id="view-groups"><span class="section-number-4">5.0.13.</span> View groups</h4>
<div class="outline-text-4" id="text-view-groups">
<pre class="example" id="org30b65ec">
p2prc --groups
</pre>
</div>
</div>
<div id="outline-container-view-specific-group" class="outline-4">
<h4 id="view-specific-group"><span class="section-number-4">5.0.14.</span> View specific group</h4>
<div class="outline-text-4" id="text-view-specific-group">
<pre class="example" id="org8d54066">
p2prc --group &lt;group id&gt;
</pre>
</div>
</div>
<div id="outline-container-delete-container-from-group" class="outline-4">
<h4 id="delete-container-from-group"><span class="section-number-4">5.0.15.</span> Delete container from group</h4>
<div class="outline-text-4" id="text-delete-container-from-group">
<pre class="example" id="org75953f1">
p2prc --rmcgroup --group &lt;group id&gt; --id &lt;container id&gt;
</pre>
</div>
</div>
<div id="outline-container-delete-entire-group" class="outline-4">
<h4 id="delete-entire-group"><span class="section-number-4">5.0.16.</span> Delete entire group</h4>
<div class="outline-text-4" id="text-delete-entire-group">
<pre class="example" id="org586c201">
p2prc --rmgroup &lt;group id&gt;
</pre>
</div>
</div>
<div id="outline-container-pulling-plugin-from-a-remote-repo" class="outline-4">
<h4 id="pulling-plugin-from-a-remote-repo"><span class="section-number-4">5.0.17.</span> Pulling plugin from a remote repo</h4>
<div class="outline-text-4" id="text-pulling-plugin-from-a-remote-repo">
<pre class="example" id="org1541192">
p2prc --pp &lt;repo link&gt;
</pre>
</div>
</div>
<div id="outline-container-deleting-plugin-from-the-plugin-directory" class="outline-4">
<h4 id="deleting-plugin-from-the-plugin-directory"><span class="section-number-4">5.0.18.</span> Deleting plugin from the plugin directory</h4>
<div class="outline-text-4" id="text-deleting-plugin-from-the-plugin-directory">
<pre class="example" id="org94da76c">
p2prc --rp &lt;plugin name&gt;
</pre>
</div>
</div>
<div id="outline-container-added-custom-metadata-about-the-current-node" class="outline-4">
<h4 id="added-custom-metadata-about-the-current-node"><span class="section-number-4">5.0.19.</span> Added custom metadata about the current node</h4>
<div class="outline-text-4" id="text-added-custom-metadata-about-the-current-node">
<pre class="example" id="orgaa3e38f">
p2prc --amd "custom metadata"
</pre>
</div>
</div>
<div id="outline-container-orgad06634" class="outline-4">
<h4 id="orgad06634"><span class="section-number-4">5.0.20.</span> MapPort and link to domain name</h4>
<div class="outline-text-4" id="text-5-0-20">
<p>
Allows to expose remote ports from a machine in the P2P network.
</p>
<pre class="example" id="org187c080">
p2prc --mp &lt;port no to map&gt; --dn &lt;domain name to link Mapped port against&gt;
</pre>
</div>
<ol class="org-ol">
<li><a id="org3d4f62d"></a>MapPort in remote machine<br />
<div class="outline-text-5" id="text-5-0-20-1">
<p>
This is to ensure ports on remote machines on the P2PRC can be easily opened.
</p>
<pre class="example" id="org792545f">
p2prc --mp &lt;port no to map&gt; --dn &lt;domain name to link Mapped port against&gt; --ra &lt;remote server address&gt;
</pre>

<hr />
</div>
</li>
</ol>
</div>
<div id="outline-container-orgfe7c95c" class="outline-4">
<h4 id="orgfe7c95c"><span class="section-number-4">5.0.21.</span> Add root node</h4>
<div class="outline-text-4" id="text-5-0-21">
<p>
Adds a root node to P2RRC and overwrites all other nodes in the ip table.
To be only added before the network is started and with
the intention of a fresh instance.
</p>
<pre class="example" id="orgba6ead9">
p2prc --arn --ip &lt;root node ip address&gt; -p &lt;root node port no&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-p2p-module-implementation" class="outline-2">
<h2 id="p2p-module-implementation"><span class="section-number-2">6.</span> P2P Module Implementation</h2>
<div class="outline-text-2" id="text-p2p-module-implementation">
<p>
The P2P module is for managing server information within the network.
It maintains and updates the IP table, ensuring accuracy by preventing duplicates and removing
entries for unreachable servers. Furthermore, the module conducts speed tests on the listed servers
to determine upload and download speeds. This valuable information enables users to identify nearby
servers with optimal performance, enhancing their overall network experience.
</p>

<p>
[[<img src="./images/p2pmoduleArch.png" alt="p2pmoduleArch.png" />]
</p>

<p>
The peer to peer implementation was built from scratch. This is because
other peer to peer libraries were on the implementation of the
Distributed hash table. At the current moment all those heavy features
are not needed because the objective is to search and list all possible
servers available. The limitation being that to be a part of the network
the user has to know at least 1 server. The advantage of building from
scratch makes the module super light and possibility for custom
functions and structs. The sub topics below will mention the
implementations of each functionality in depth.
</p>
</div>
<div id="outline-container-ip-table" class="outline-3">
<h3 id="ip-table"><span class="section-number-3">6.1.</span> IP Table</h3>
<div class="outline-text-3" id="text-ip-table">
<p>
The ip table file is a json as the format with a list of servers ip
addresses, latencies, downloads and uploads speeds. The functions
implemented include read file, write file and remove duplicate IP
addresses. The remove duplicate IP address function exists because
sometimes servers IP tables can have the same ip addresses as what the
client has. The path of the IP table json file is received from the
configuration module.
</p>

<div class="org-src-container">
<pre class="src src-json">{
  "ip_address": [
    {
                        "Name": "&lt;hostname of the machine&gt;",
                        "MachineUsername": "&lt;machine username&gt;",
                        "IPV4": "&lt;ipv4 address&gt;",
                        "IPV6": "&lt;ipv6 address (Not used)&gt;",
                        "Latency": &lt;latency to the server&gt;,
                        "Download": &lt;download speed (Not used)&gt;,
                        "Upload": &lt;upload speed (Not used)&gt;,
                        "ServerPort": "&lt;server port no&gt;",
                        "BareMetalSSHPort": "&lt;Baremetal ssh port no&gt;",
                        "NAT": "&lt;boolean representing if the node is behind NAT or not&gt;",
                        "EscapeImplementation": "&lt;NAT traversal implementation&gt;",
                        "ProxyServer": "&lt;If the node listed is acting as a proxy server&gt;",
                        "UnSafeMode": &lt;Unsafe mode if turned on will allow all nodes in the network public keys to be
      added to that particular node&gt;",
                        "PublicKey": "&lt;Public key of that particular node&gt;",
                        "CustomInformation": "&lt;custom information passed in through all the nodes in the network&gt;"
                }
  ]
}
</pre>
</div>
</div>
<div id="outline-container-latency" class="outline-4">
<h4 id="latency"><span class="section-number-4">6.1.1.</span> Latency</h4>
<div class="outline-text-4" id="text-latency">
<p>
The latency is measured in milliseconds. The route /server<sub>info</sub> is
called from the server and time it takes to provide a json response is
recorded.
</p>
</div>
</div>
</div>
<div id="outline-container-nat-traversal" class="outline-3">
<h3 id="nat-traversal"><span class="section-number-3">6.2.</span> NAT Traversal</h3>
<div class="outline-text-3" id="text-nat-traversal">
<p>
P2PRC currently supports TURN for NAT traversal.
</p>
</div>
</div>
<div id="outline-container-turn" class="outline-3">
<h3 id="turn"><span class="section-number-3">6.3.</span> TURN</h3>
<div class="outline-text-3" id="text-turn">
<p>
The current TURN implementation used is FRP. The TURN server is also
required when a P2PRC node is acting as a Server. The TURN server is
determined based on the Node with the least amount of latency based on
the Nodes available on the IPTable. Once a TURN server is determined
there are 2 actions performed. The first one is <code>/FRPPort</code> to the TURN
server to receive a port which is used to generate the external port
from the TURN server. The flow below describes the workflow.
</p>
</div>
<div id="outline-container-client-mode" class="outline-4">
<h4 id="client-mode"><span class="section-number-4">6.3.1.</span> Client mode</h4>
<div class="outline-text-4" id="text-client-mode">
<ul class="org-ul">
<li>Call <code>/FRPPort</code></li>
</ul>

<pre class="example" id="org0d62959">
http://&lt;turn server ip&gt;:&lt;server port no&gt;/FRPport
</pre>

<ul class="org-ul">
<li>Call the TURN server in the following manner. The following is a
sample code snippet below.</li>
</ul>

<div class="org-src-container">
<pre class="src src-go">import (
    "github.com/Akilan1999/p2p-rendering-computation/p2p/frp"
)

func main() {
  serverPort, err := frp.GetFRPServerPort("http://" + &lt;lowestLatencyIpAddress.Ipv4&gt; + ":" + lowestLatencyIpAddress.ServerPort)
   if err != nil {
    return nil, err
   }
   // Create 1 second delay to allow FRP server to start
   time.Sleep(1 * time.Second)
   // Starts FRP as a client with
   proxyPort, err := frp.StartFRPClientForServer(&lt;lowestLatencyIpAddress.Ipv4&gt;, serverPort, &lt;the port you want to expose externally&gt;)
   if err != nil {
     return nil, err
   }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-language-bindings" class="outline-2">
<h2 id="language-bindings"><span class="section-number-2">7.</span> Language Bindings</h2>
<div class="outline-text-2" id="text-language-bindings">
<p>
<a href="https://en.wikipedia.org/wiki/Language_binding">Language bindings</a>
refers to wrappers to bridge 2 programming languages. This is used in
P2PRC to extend calling P2PRC functions in other programming languages.
Currently this is done by generating <code>.so</code> and <code>.h</code> from the Go
compiler.
</p>
</div>
<div id="outline-container-how-to-build-shared-object-files" class="outline-3">
<h3 id="how-to-build-shared-object-files"><span class="section-number-3">7.1.</span> How to build shared object files</h3>
<div class="outline-text-3" id="text-how-to-build-shared-object-files">
</div>
<ol class="org-ol">
<li><a id="the-easier-way"></a>The easier way<br />
<div class="outline-text-5" id="text-the-easier-way">
<div class="org-src-container">
<pre class="src src-sh"># Run
make sharedObjects
</pre>
</div>
</div>
</li>
<li><a id="or-the-direct-way"></a>Or the direct way<br />
<div class="outline-text-5" id="text-or-the-direct-way">
<div class="org-src-container">
<pre class="src src-sh"># Run
cd Bindings &amp;&amp; go build -buildmode=c-shared -o p2prc.so
</pre>
</div>
</div>
</li>
<li><a id="if-successfully-built"></a>If successfully built:<br />
<div class="outline-text-5" id="text-if-successfully-built">
<div class="org-src-container">
<pre class="src src-sh"># Enter into the Bindings directory
cd Bindings
# List files
ls
# Find files
p2prc.h p2prc.so
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-workings-under-the-hood" class="outline-3">
<h3 id="workings-under-the-hood"><span class="section-number-3">7.2.</span> Workings under the hood</h3>
<div class="outline-text-3" id="text-workings-under-the-hood">
<p>
Below are a sample set of commands to open the bindings implementation.
</p>

<pre class="example" id="orga56b929">
# run
cd Bindings/
# list files
ls
# search for file
Client.go
</pre>
</div>
<div id="outline-container-in-client-go" class="outline-4">
<h4 id="in-client-go"><span class="section-number-4">7.2.1.</span> In Client go</h4>
<div class="outline-text-4" id="text-in-client-go">
<p>
There a few things to notice which are different from your standard Go
programs:
</p>
</div>
<ol class="org-ol">
<li><a id="we-import-c-which-means-cgo-is-required."></a>1. We import "C" which means <a href="https://pkg.go.dev/cmd/cgo">Cgo</a> is required.<br />
<div class="outline-text-5" id="text-we-import-c-which-means-cgo-is-required.">
<div class="org-src-container">
<pre class="src src-go">import "C"
</pre>
</div>
</div>
</li>
<li><a id="all-functions-which-are-required-to-be-called-from-other-programming-languages-have-comment-such-as."></a>2. All functions which are required to be called from other programming languages have comment such as.<br />
<div class="outline-text-5" id="text-all-functions-which-are-required-to-be-called-from-other-programming-languages-have-comment-such-as.">
<div class="org-src-container">
<pre class="src src-go">//export &lt;function name&gt;

// ------------ Example ----------------
// The function below allows to externally
// to call the P2PRC function to start containers
// in a specific node in the know list of nodes
// in the p2p network.
// Note: the comment "//export StartContainer".

//export StartContainer
func StartContainer(IP string) (output *C.char) {
     container, err := client.StartContainer(IP, 0, false, "", "")
     if err != nil {
         return C.CString(err.Error())
     }
     return ConvertStructToJSONString(container)
 }
</pre>
</div>
</div>
</li>
<li><a id="while-looking-through-the-file-if-2-files-are-compared-it-is-pretty-trivial-to-notice-a-common-structure."></a>3. While looking through the file (If 2 files are compared it is pretty trivial to notice a common structure).<br />
<div class="outline-text-5" id="text-while-looking-through-the-file-if-2-files-are-compared-it-is-pretty-trivial-to-notice-a-common-structure.">
<div class="org-src-container">
<pre class="src src-go">// --------- Example ------------

//export StartContainer
func StartContainer(IP string) (output *C.char) {
     container, err := client.StartContainer(IP, 0, false, "", "")
     if err != nil {
         return C.CString(err.Error())
     }
     return ConvertStructToJSONString(container)
}

//export ViewPlugin
func ViewPlugin() (output *C.char) {
    plugins, err := plugin.DetectPlugins()
    if err != nil {
        return C.CString(err.Error())
    }
    return ConvertStructToJSONString(plugins)
}
</pre>
</div>
</div>
</li>
<li><a id="it-is-easy-to-notice-that"></a>It is easy to notice that:<br />
<div class="outline-text-5" id="text-it-is-easy-to-notice-that">
<ul class="org-ul">
<li><code>ConvertStructToJSONString(&lt;go object&gt;)</code>: This is a helper function
that convert a go object to JSON string initially and converts it to
<code>CString</code>.</li>
<li><code>(output *C.char)</code>: This is the return type for most of the functions.</li>
</ul>
</div>
</li>
<li><a id="a-pseudo-code-to-refer-to-the-common-function-implementation-shape-could-be-represented-as"></a>A Pseudo code to refer to the common function implementation shape could be represented as:<br />
<div class="outline-text-5" id="text-a-pseudo-code-to-refer-to-the-common-function-implementation-shape-could-be-represented-as">
<pre class="example" id="org459d3b1">
func &lt;Function name&gt; (output *C.char) {
      &lt;response&gt;,&lt;error&gt; := &lt;P2PRC function name&gt;(&lt;parameters if needed&gt;)
      if &lt;error&gt; != nil {
          return C.CString(&lt;error&gt;.Error())
      }
      return ConvertStructToJSONString(&lt;response&gt;)
}
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-current-languages-supported" class="outline-3">
<h3 id="current-languages-supported"><span class="section-number-3">7.3.</span> Current languages supported</h3>
<div class="outline-text-3" id="text-current-languages-supported">
</div>
<div id="outline-container-org2c0e1e0" class="outline-4">
<h4 id="org2c0e1e0"><span class="section-number-4">7.3.1.</span> Python</h4>
<div class="outline-text-4" id="text-7-3-1">
</div>
<ol class="org-ol">
<li><a id="build-sample-python-program"></a>Build sample python program<br />
<div class="outline-text-5" id="text-build-sample-python-program">
<p>
The easier way
</p>

<div class="org-src-container">
<pre class="src src-sh"># Run
make python
# Expected ouput
Output is in the Directory Bindings/python/export/
# Run
cd Bindings/python/export/
# list files
ls
# Expected output
SharedObjects/  library.py requirements.txt
</pre>
</div>

<p>
Above shows a generated folder which consists of a folder called
"SharedObjects/" which consists of <code>p2prc.so</code> and <code>p2prc.h</code> files.
<code>p2prc.py</code> refers to a sample python script calling P2PRC go functions.
To start an any project to extend P2PRC with python, This generated
folder can copied and created as a new git repo for P2PRC extensions
scripted or used a reference point as proof of concept that P2PRC can be
called from other programming languages.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org6e90444" class="outline-4">
<h4 id="org6e90444"><span class="section-number-4">7.3.2.</span> Haskell</h4>
<div class="outline-text-4" id="text-7-3-2">
<p>
P2PRC officially supports Haskell bindings and will further support
project using Haskell to build orchestrators on top of P2PRC.
</p>
</div>
<ol class="org-ol">
<li><a id="orgc2885f1"></a>Local machine without Nix<br />
<div class="outline-text-5" id="text-7-3-2-1">
<p>
On the local machine we just create a folder as exports which copies the p2prc haskell bindings
and the latest build of the p2prc binary. After the binary is copied it runs the &#x2013;dc in p2prc to setup the
basic p2prc configurations. To do the following just do:
</p>
<pre class="example" id="orgeb6eab3">
make haskell
</pre>
</div>
</li>
<li><a id="org10fe9c0"></a>Directory to enter into<br />
<div class="outline-text-5" id="text-7-3-2-2">
<pre class="example" id="org22accc0">
cd Bindings/Haskell/exports
</pre>
</div>
</li>
<li><a id="org532fdb8"></a>Run<br />
<div class="outline-text-5" id="text-7-3-2-3">
<pre class="example" id="orgc549759">
- cabal build
- cabal run
</pre>

<p>
<a href="https://p2prc.akilan.io/haskell">Read more&#x2026;</a>
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org833da84" class="outline-3">
<h3 id="org833da84"><span class="section-number-3">7.4.</span> Building P2PRC modules in Rust</h3>
<div class="outline-text-3" id="text-7-4">
<p>
This refers to building parts of p2prc internal implementation in Rust. As it
stands Rust has great C FFI bindings to Go. This decision aligns with our
future plans to have the bare basic functionality in Golang and to write
future enhanced features in Rust.
</p>
</div>
<div id="outline-container-orga14ed63" class="outline-4">
<h4 id="orga14ed63"><span class="section-number-4">7.4.1.</span> A simple Hello Rust module</h4>
<div class="outline-text-4" id="text-7-4-1">
<p>
You can find the source code in <code>rustlibrary/p2prc_rust_module</code>.
We will reproduce this step by step to make it easier for you
to build your own p2prc rust module.
We will be using the Rust library <a href="https://github.com/ihciah/rust2go">rust2go</a>
as there is a fantastic write up on the inner workings
of the library, which can be found <a href="https://orgmode.org/manual/Working-with-Source-Code.html">here</a>. The sample Rust
module below is based on the following <a href="https://github.com/ihciah/rust2go/tree/master/examples/example-go2rust">tutorial</a>.
</p>
</div>
<ol class="org-ol">
<li><a id="orgb05866f"></a>Create a Cargo project<br />
<div class="outline-text-5" id="text-7-4-1-1">
<div class="org-src-container">
<pre class="src src-bash">cargo new &lt;project name&gt; --bin
# Install the cli to convert your automate binding
# your Rust to CGo bindings. 
cargo install --force rust2go-cli
</pre>
</div>
</div>
</li>
<li><a id="orge047791"></a>Add dependencies to the <code>cargo.toml</code> file<br />
<div class="outline-text-5" id="text-7-4-1-2">
<div class="org-src-container">
<pre class="src src-toml">[lib]
# If you only wanted dynamic library, you'd use only "cdylib".
# If you only wanted static library, you'd use only "staticlib".
# This demo shows both. See https://doc.rust-lang.org/reference/linkage.html
# for more information.
crate-type = ["cdylib", "staticlib"]

[dependencies]
libc = "0.2.2"
rust2go = "0.4.1"

[build-dependencies]
rust2go = { version = "0.4.1", features = ["build"] }
</pre>
</div>
</div>
</li>
<li><a id="org94bc810"></a>Write a simple Rust program for our test project:<br />
<div class="outline-text-5" id="text-7-4-1-3">
<p>
We will create 2 files in the <code>src</code> directory. We will have
the file names with the source code below.
</p>
</div>
<ol class="org-ol">
<li><a id="org5c34e2b"></a><code>lib.rs</code><br />
<div class="outline-text-6" id="text-7-4-1-3-1">
<p>
Implementation of the trait done manually. 
</p>
<div class="org-src-container">
<pre class="src src-Rust">use user::{DemoUser, G2RCall, G2RCallImpl};

mod user;

impl G2RCall for G2RCallImpl {
    fn demo_log(name: String, age: u8) {
        println!("[Rust Callee] log user {name} and age {age}");
    }

    fn demo_convert_name(user: DemoUser) -&gt; String {
        let new_user_name = user.name.to_ascii_uppercase();
        println!(
            "[Rust Callee] convert user username: {} -&gt; {new_user_name}",
            user.name
        );
        new_user_name
    }
}
</pre>
</div>
</div>
</li>
<li><a id="orgd80d030"></a><code>user.rs</code><br />
<div class="outline-text-6" id="text-7-4-1-3-2">
<p>
Define the request and response structs and calling conventions are in <code>user.rs</code>. You should also add
<code>#[derive(rust2go::R2G)]</code> to your structs and <code>#[rust2go::g2r]</code> to your traits.
</p>
<div class="org-src-container">
<pre class="src src-rust">// Define your own structs. You must derive `rust2go::R2G` for each struct.
#[derive(rust2go::R2G, Clone)]
pub struct DemoUser {
    pub name: String,
    pub age: u8,
}

// Define your own structs. You must derive `rust2go::R2G` for each struct.
#[derive(rust2go::R2G, Clone, Copy)]
#[allow(dead_code)]
pub struct DemoResponse {
    pub pass: bool,
}

#[rust2go::g2r]
pub trait G2RCall {
    fn demo_log(name: String, age: u8);
    fn demo_convert_name(user: DemoUser) -&gt; String;}
</pre>
</div>
</div>
</li>
</ol>
</li>
<li><a id="orge577026"></a>Generating Go FFI bindings<br />
<div class="outline-text-5" id="text-7-4-1-4">
<div class="org-src-container">
<pre class="src src-bash"># Enter your Rust root directory, in our case:
cd rustlibrary/p2prc_rust_module
# Build the Rust module
cargo build --release
# Copy loaded .a (https://en.wikipedia.org/wiki/Library_%28computing%29#Static_libraries) file
# to root directory of p2prc or your project. In the case here our Rust module is 2
# layers deep from the Go root directory. 
cp target/release/libp2prc_loaded.a ../../
# enter to the root directory
cd ../../
# Generate go program (gen.go) to bind with the .a file
rust2go-cli --src rustlibrary/p2prctest/src/user.rs --dst rustlibrary/gen.go --without-main
# After this go to the section below on "After the last step..." and "Defining the Go package"
# Build with the "rust" tag to allow the rust module to link with the go program.
go build -tags rust -o p2prc
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="orgf01d4e1"></a>After the last step, we need to do a minor change in the generated <code>gen.go</code>. This can be found in <code>rustlibrary/gen.go</code>.<br />
<div class="outline-text-6" id="text-7-4-1-4-1">
<div class="org-src-container">
<pre class="src src-bash">// Change it to package &lt;your package name&gt;
package rustlibrary

/*
// Generated by rust2go. Please DO NOT edit this C part manually.
...
</pre>
</div>
</div>
</li>
</ol>
</li>
<li><a id="orgc9bc2da"></a>Defining the Go package<br />
<div class="outline-text-5" id="text-7-4-1-5">
<p>
In our example, we created a package called <code>rustlibrary</code>.
We will now also create 2 files called <code>test_rust.go</code> and <code>test_not_rust.go</code>.
<code>test_rust.go</code> file consists of the Go program calling the rust implemented functions.
</p>
<div class="org-src-container">
<pre class="src src-go">//This ensures that only when the rust tag is
// produced on build we should then include this
// file on compile time.  
//go:build rust

package rustlibrary

import "fmt"
/*
// For statically link: #cgo LDFLAGS: ./librust_lib.a
// For dynamically link: #cgo LDFLAGS: -L. -lrust_lib
#cgo LDFLAGS: &lt;path of the statically linked file&gt;
*/
import "C"

func TestRust() {
    // Defined in the gen.go file
    // This file was auto generated
    // by rust2go. 
    user := DemoUser{
        name: "chihai",
        age:  28,
    }
    // calling rust functions
    G2RCallImpl{}.demo_log(&amp;user.name, &amp;user.age)
    newName := G2RCallImpl{}.demo_convert_name(&amp;user)
    fmt.Printf("new name: %s", newName)
}
</pre>
</div>
<p>
We will create a new file (i.e <code>test_not_rust.go</code>) with the same function shape.
But now allows it to build as the default because the <code>rust</code> tag
is not provided.
</p>
<div class="org-src-container">
<pre class="src src-go">//go:build !rust

// Package rustlibrary
// This is samle package that mentions to the go program that
// the rust .a file is not linked to the binary. This is to
// always allow p2prc to work with pure go.
package rustlibrary

import "fmt"

func TestRust() {
    fmt.Println("Rust module not built")
}
</pre>
</div>
<p>
We will now add the call of the test rust module
as a p2prc cli command. We will modify these 2 files:
</p>
</div>
<ol class="org-ol">
<li><a id="org451de4b"></a><code>cmd/flag.go</code><br />
<div class="outline-text-6" id="text-7-4-1-5-1">
<div class="org-src-container">
<pre class="src src-go">package cmd

import (
        "github.com/urfave/cli/v2"
)

// Variables declared for CLI
var (
   ...
    // Test calling rust code
    // It's a boolean flag
    // Since we only want
    // to trigger the
    // rust function
    CallRustProgram bool
)
...
var AppConfigFlags = []cli.Flag{
...
// Registers the command line flag. 
&amp;cli.BoolFlag{
                Name:        "CallRustProgram",
                Aliases:     []string{"crp"},
                Usage:       "Experimental: Call test Rust program",
                EnvVars:     []string{"CRP"},
                Destination: &amp;CallRustProgram,
  },
}  
</pre>
</div>
</div>
</li>
<li><a id="org5a068e9"></a><code>cmd/action.go</code><br />
<div class="outline-text-6" id="text-7-4-1-5-2">
<div class="org-src-container">
<pre class="src src-go">package cmd

import (
    ...
    // Import test rust module
    "github.com/Akilan1999/p2p-rendering-computation/rustlibrary"
    ...
)
var CliAction = func(ctx *cli.Context) error {
  ...
  // Run the test rust program
    if CallRustProgram {
        rustlibrary.TestRust()

  }
  ...
  return nil
}
...

</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-org6a54c3a" class="outline-4">
<h4 id="org6a54c3a"><span class="section-number-4">7.4.2.</span> Important notes for creates future Rust modules</h4>
<div class="outline-text-4" id="text-7-4-2">
<p>
You can build the test module with the following command:
</p>
<div class="org-src-container">
<pre class="src src-bash">make install-rust
# call the test flag
p2prc --CallRustProgram
# Response
[Rust Callee] log user chihai and age 28
[Rust Callee] convert user username: chihai -&gt; CHIHAI
new name: CHIHAI
</pre>
</div>
<p>
Ensure that all rust modules imported can be compiled with the
tag <code>rust</code>. An example that should work would be <code>go build -tags rust -o p2prc</code>.
As it stands, we will official only accept modules which are statically compiled
so that everything stays in a single binary. 
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-config-implementation" class="outline-2">
<h2 id="config-implementation"><span class="section-number-2">8.</span> Config Implementation</h2>
<div class="outline-text-2" id="text-config-implementation">
<p>
The configuration module is responsible to store basic information of
absolute paths of files being called in the Go code. In a full-fledged
Cli the configuration file can be found in the directory <i>etc</i> and from
there points to location such as where the IP table file is located. In
the future implementation the config file will have information such as
number of hops and other parameters to tweak and to improve the
effectiveness of the peer to peer network. The configuration module was
implemented using the library Viper. The Viper library automates
features such as searching in default paths to find out if the
configuration file is present. If the configuration file is not present
in the default paths then it auto generates the configuration file. The
configurations file can be in any format. In this project the
configuration file was generated using JSON format.
</p>

<div class="org-src-container">
<pre class="src src-json">{
 "MachineName": "Akilans-MacBook-Pro.local-975261X",
 "IPTable": "/Users/akilan/Documents/p2p-rendering-computation/p2p/iptable/ip_table.json",
 "DockerContainers": "/Users/akilan/Documents/p2p-rendering-computation/server/docker/containers/",
 "DefaultDockerFile": "/Users/akilan/Documents/p2p-rendering-computation/server/docker/containers/docker-ubuntu-sshd/",
 "DockerRunLogs": "/tmp/",
 "SpeedTestFile": "/Users/akilan/Documents/p2p-rendering-computation/p2p/50.bin",
 "IPV6Address": "",
 "PluginPath": "/Users/akilan/Documents/p2p-rendering-computation/plugin/deploy",
 "TrackContainersPath": "/Users/akilan/Documents/p2p-rendering-computation/client/trackcontainers/trackcontainers.json",
 "ServerPort": "8088",
 "ProxyPort": "",
 "GroupTrackContainersPath": "/Users/akilan/Documents/p2p-rendering-computation/client/trackcontainers/grouptrackcontainers.json",
 "FRPServerPort": true,
 "BehindNAT": true,
 "IPTableKey": "QH3yQrGRe2X4",
 "PublicKeyFile": "/Users/akilan/Documents/p2p-rendering-computation/p2prc.publicKey",
 "PrivateKeyFile": "/Users/akilan/Documents/p2p-rendering-computation/p2prc.privateKey",
 "PemFile": "/Users/akilan/Documents/p2p-rendering-computation/cert.pem",
 "KeyFile": "/Users/akilan/Documents/p2p-rendering-computation/key.pem",
 "BareMetal": false,
 "UnsafeMode": false,
 "Test": false,
 "CustomConfig": null
}
</pre>
</div>
</div>
</div>
<div id="outline-container-abstractions" class="outline-2">
<h2 id="abstractions"><span class="section-number-2">9.</span> Abstractions</h2>
<div class="outline-text-2" id="text-abstractions">
<p>
The Abstractions package consists of black-boxed functions for P2PRC.
</p>
</div>
<div id="outline-container-functions" class="outline-3">
<h3 id="functions"><span class="section-number-3">9.1.</span> Functions</h3>
<div class="outline-text-3" id="text-functions">
<ul class="org-ul">
<li><code>Init(&lt;Project name&gt;)</code>: Initializes P2PRC with all the needed
configurations.</li>
<li><code>Start()</code>: Starts p2prc as a server and makes it possible to extend by
adding other routes and functionality to P2PRC.</li>
<li><code>MapPort(&lt;port no&gt;)</code>: On the local machine the port you want to export
to world.</li>
<li><code>StartContainer(&lt;ip address&gt;)</code>: The machine on the p2p network where
you want to spin up a docker container.</li>
<li><code>RemoveContainer(&lt;ip address&gt;,&lt;container id&gt;)</code>: Terminate container
based on the IP address and container name.</li>
<li><code>GetSpecs(&lt;ip address&gt;)</code>: Get specs of a machine on the network based
on the IP address.</li>
<li><code>ViewIPTable()</code>: View the IP table which about nodes in the network.</li>
<li><code>UpdateIPTable()</code>: Force update IP table to learn about new nodes
faster.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-nat-traversal" class="outline-2">
<h2 id="nat-traversal"><span class="section-number-2">10.</span> NAT Traversal</h2>
<div class="outline-text-2" id="text-nat-traversal">
<p>
P2PRC currently supports TURN for NAT traversal.
</p>
</div>
<div id="outline-container-turn" class="outline-3">
<h3 id="turn"><span class="section-number-3">10.1.</span> TURN</h3>
<div class="outline-text-3" id="text-turn">
<p>
The current TURN implementation used is FRP. The TURN server is also
required when a P2PRC node is acting as a Server. The TURN server is
determined based on the Node with the least amount of latency based on
the Nodes available on the IPTable. Once a TURN server is determined
there are 2 actions performed. The first one is <code>/FRPPort</code> to the TURN
server to receive a port which is used to generate the external port
from the TURN server. The flow below describes the workflow.
</p>
</div>
</div>
</div>
<div id="outline-container-client-mode" class="outline-2">
<h2 id="client-mode"><span class="section-number-2">11.</span> Client mode</h2>
<div class="outline-text-2" id="text-client-mode">
<ul class="org-ul">
<li>Call <code>/FRPPort</code></li>
</ul>

<pre class="example" id="orgbf8ba23">
http://&lt;turn server ip&gt;:&lt;server port no&gt;/FRPport
</pre>

<ul class="org-ul">
<li>Call the TURN server in the following manner. The following is a
sample code snippet below.</li>
</ul>

<div class="org-src-container">
<pre class="src src-go">import (
    "github.com/Akilan1999/p2p-rendering-computation/p2p/frp"
)

func main() {
  serverPort, err := frp.GetFRPServerPort("http://" + &lt;lowestLatencyIpAddress.Ipv4&gt; + ":" + lowestLatencyIpAddress.ServerPort)
   if err != nil {
    return nil, err
   }
   // Create 1 second delay to allow FRP server to start
   time.Sleep(1 * time.Second)
   // Starts FRP as a client with
   proxyPort, err := frp.StartFRPClientForServer(&lt;lowestLatencyIpAddress.Ipv4&gt;, serverPort, &lt;the port you want to expose externally&gt;)
   if err != nil {
     return nil, err
   }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org5f3cbd3" class="outline-2">
<h2 id="org5f3cbd3"><span class="section-number-2">12.</span> Simulation</h2>
<div class="outline-text-2" id="text-12">
<p>
The simulation library is a really simple library to locally
run serveral instances of P2PRC to test the functionality
of sending information through the network and particularly
the Node discovery mechanism. There are current 5 commands
which can be used as shown below:
</p>
</div>
<div id="outline-container-orgfd89349" class="outline-3">
<h3 id="orgfd89349"><span class="section-number-3">12.1.</span> Command</h3>
<div class="outline-text-3" id="text-12-1">
<ul class="org-ul">
<li><b><b><b>P2PRC instances "number of instances"</b></b></b> : Starts p2prc processes
based on the number of number instances provided. This includes
creating temporary folders with independent IPTables.</li>
<li><b><b><b>Start all instances "number of instances"</b></b></b>: Starts the P2PRC instances
created. This function enters into the instance directory and runs
```p2prc -s &amp;``` with a delay for approximately 3 seconds. This allows
each independent created node to learn about each other.</li>
<li><b><b><b>IP Tables after Started number of instances"</b></b></b>: Prints the IPTable of
each independant node.</li>
<li><b><b><b>Remove all test files</b></b></b>: Removes all test files created which needed for
testing the generated P2PRC instances.</li>
<li><b><b><b>Kill all instances</b></b></b>: Kills all the background P2PRC instances created.</li>
</ul>
</div>
</div>
<div id="outline-container-orgfa04801" class="outline-3">
<h3 id="orgfa04801"><span class="section-number-3">12.2.</span> Sample bash instructions</h3>
<div class="outline-text-3" id="text-12-2">
<div class="org-src-container">
<pre class="src src-bash"># Unset default P2PRC env path
unset P2PRC

# Run with 2 nodes
P2PRC_instances 3

# Start instances
Start_all_instances 3

# List ip tables of nodes started
IP_Tables_after_Started 3

# Remove test files created
Remove_all_test_files

# Kill all instances
Kill_all_instances
</pre>
</div>
<p>
Source code: <a href="https://github.com/Akilan1999/p2p-rendering-computation/blob/master/Simulation/simulation.sh">https://github.com/Akilan1999/p2p-rendering-computation/blob/master/Simulation/simulation.sh</a>
</p>
</div>
</div>
</div>
<div id="outline-container-orge4d9db0" class="outline-2">
<h2 id="orge4d9db0"><span class="section-number-2">13.</span> Blog posts</h2>
<div class="outline-text-2" id="text-13">
</div>
<div id="outline-container-orgfca689c" class="outline-3">
<h3 id="orgfca689c"><span class="section-number-3">13.1.</span> Self host within 5 minutes any program</h3>
<div class="outline-text-3" id="text-13-1">
<ul class="org-ul">
<li>Author: <a href="http://akilan.io/">Akilan Selvacoumar</a></li>
<li>Date: 28-01-2025</li>
</ul>


<ul class="org-ul">
<li>Video tutorial:</li>
</ul>

<div id="org0b71325" class="figure">
<p><a href="https://youtu.be/rN4SiVowg5E" class="video"><img src="https://i3.ytimg.com/vi/rN4SiVowg5E/maxresdefault.jpg" alt="maxresdefault.jpg" class="video" /></a>
</p>
</div>

<p>
This is a fun expirement for anyone to try to quickly run a server and
quickly do a map port and domain name mapping in a single command.
</p>
</div>
<div id="outline-container-org913042c" class="outline-4">
<h4 id="org913042c"><span class="section-number-4">13.1.1.</span> 1. Find a program you want to run</h4>
<div class="outline-text-4" id="text-13-1-1">
<p>
Let's try to setup a really easy program (Let's do with Linkwarden
with docker compose :) ). This is under the assumption you have docker
compose installed on your local machine.
</p>
</div>
<ol class="org-ol">
<li><a id="org20e4cba"></a>Let's run Linkwarden using docker compose and P2PRC<br />
<div class="outline-text-5" id="text-13-1-1-1">
<p>
<a href="https://docs.linkwarden.app/self-hosting/installation">Installation instructions</a>:
</p>
<div class="org-src-container">
<pre class="src src-nil">mkdir linkwarden &amp;&amp; cd linkwarden
curl -O https://raw.githubusercontent.com/linkwarden/linkwarden/refs/heads/main/docker-compose.yml
curl -L https://raw.githubusercontent.com/linkwarden/linkwarden/refs/heads/main/.env.sample -o ".env"
</pre>
</div>

<p>
Environment configuration
</p>
<div class="org-src-container">
<pre class="src src-nil">vim .env

# Change values
NEXTAUTH_URL=https://&lt;DOMAIN NAME&gt;/api/v1/auth
NEXTAUTH_SECRET=VERY_SENSITIVE_SECRET
POSTGRES_PASSWORD=CUSTOM_POSTGRES_PASSWORD
</pre>
</div>
<p>
Run linkwarden!
</p>
<div class="org-src-container">
<pre class="src src-nil">docker compose up
</pre>
</div>

<p>
If setup correctly linkwarden should
be running.
Local link: <a href="http://localhost:3000">http://localhost:3000</a>
</p>

<p>
Time to setup P2PRC
<a href="https://p2prc.akilan.io/Docs/#build-project-and-install-project">Installation Instructions</a>
</p>

<p>
Run p2prc as a background
</p>
<div class="org-src-container">
<pre class="src src-nil">p2prc -s &amp;
</pre>
</div>

<p>
Run map port and domain mapping
</p>
<div class="org-src-container">
<pre class="src src-nil">p2prc --mp 3000 --dn &lt;DOMAIN NAME&gt;
</pre>
</div>

<p>
Sample response
</p>
<div class="org-src-container">
<pre class="src src-nil"> {
        "IPAddress": "217.76.63.222",
        "PortNo": "61582",
        "EntireAddress": "217.76.63.222:61582"
}
</pre>
</div>

<p>
Add DNS entry
</p>
<div class="org-src-container">
<pre class="src src-nil">A entry 217.76.63.222
</pre>
</div>

<p>
Your done now just head to the DOMAIN NAME you added.
ex: <a href="https://linkwarden.akilan.io">https://linkwarden.akilan.io</a>
</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org57efbd3" class="outline-2">
<h2 id="org57efbd3"><span class="section-number-2">14.</span> Ideas for future potencial features</h2>
<div class="outline-text-2" id="text-14">
<p>
Consists of personal loideas for the future of P2PRC.
At moment only has main contributors writiing to this.
</p>
</div>
<div id="outline-container-org49c2bde" class="outline-3">
<h3 id="org49c2bde"><span class="section-number-3">14.1.</span> To support hetrogenous set of Nodes that cannot run P2PRC</h3>
<div class="outline-text-3" id="text-14-1">
<p>
This stems from a personal issue I have when doing research
on <a href="https://github.com/CTSRD-CHERI/cheribsd">CheriBSD</a> kernel. For my research I am using the ARM morello
which is a 128bit ARMv8 processor. At the moment Go programs
can cannot compile and run inside the CPU. This means I cannot
run P2PRC at the moment inside the ARM morello to remotely access
it when it's behind NAT using P2PRC. This would indeed be a common
problem when running against various Architectures that do not
support running P2PRC. As you will see soon this also creates
oppurtunity space to scale faster to nodes in a local network
and would introduce a new layer fault tolerance within a local
network nodes.
</p>
</div>
<div id="outline-container-org3252eff" class="outline-4">
<h4 id="org3252eff"><span class="section-number-4">14.1.1.</span> Assumptions:</h4>
<div class="outline-text-4" id="text-14-1-1">
<ul class="org-ul">
<li>I have a Morello board that cannot run P2PRC</li>
<li>The Morello has a local IP address (ex: 192.168.0.10)</li>
<li>I have 2 laptops running P2PRC in that local network.</li>
<li>This means I have 2 ways to access the Morello board: Which is to SSH
into either 2 laptops and then SSH into 192.168.0.10 to gain access
to the board. Wouldn't it be great to automate this whole layer and
as well look into custom tasks into the hetrogenous hardware.</li>
</ul>
</div>
</div>
<div id="outline-container-orgdfb7f68" class="outline-4">
<h4 id="orgdfb7f68"><span class="section-number-4">14.1.2.</span> Set of interesting possible:</h4>
<div class="outline-text-4" id="text-14-1-2">
<p>
We build a cool set possibilities before and use this to build up the implementation
plan.
</p>
<ul class="org-ul">
<li>We can use P2PRC access the morello board remotely in a single command.</li>
<li>We can use the P2PRC protocol to run servers inside the morello board via traversed
node locally which can access that Node.</li>
<li>Spin servers on node not running P2PRC using the P2PRC standard abstractions.</li>
<li>Auto-setup P2PRC nodes with just SSH access via potencially a DSL.</li>
<li>A neat use case for CHERI for instance would be use the architecture to run light
weight hypervisors.</li>
</ul>
</div>
</div>
<div id="outline-container-org4bd7b29" class="outline-4">
<h4 id="org4bd7b29"><span class="section-number-4">14.1.3.</span> Implementation</h4>
<div class="outline-text-4" id="text-14-1-3">
<ul class="org-ul">
<li>To use implementations similar to <a href="https://linux.die.net/man/1/socat">socat</a> to ensure we can bind address of local
nodes to a node running P2PRC and the node running P2PRC can do a local map port.</li>
<li>We are working on hardening the implementation of the &#x2013;mp (Map port) to even
map ports to machines which remotely running P2PRC. This means of instance I
can issue a command to the Morello board without the morello board being in
my local network.</li>
<li>We would want to implement the exsisting P2PRC public key mechanism as well so that
other nodes can access the Morello board who have permission access.</li>
</ul>


<div id="org838c8dc" class="figure">
<p><img src="./images/P2PRCRemoteNodes.png" alt="P2PRCRemoteNodes.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Implementation idea (To be improved upon)</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Akilan</p>
<p class="date">Created: 2025-12-24 Wed 21:58</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
